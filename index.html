<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smart Home Mesh Dashboard</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      max-width: 960px;
      width: 100%;
      padding: 24px 16px 32px;
    }
    h1 {
      margin-top: 0;
      font-size: 1.6rem;
      text-align: center;
      margin-bottom: 4px;
      letter-spacing: 0.03em;
    }
    .mode {
      text-align: center;
      font-size: 0.85rem;
      opacity: 0.75;
      margin-bottom: 8px;
    }

    /* Mode badge */
    .mode-badge-wrapper {
      text-align: center;
      margin-bottom: 12px;
    }
    .mode-badge {
      font-size: 0.78rem;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid transparent;
      display: inline-block;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .mode-badge.router-cloud {
      background: rgba(34,197,94,0.12);
      border-color: rgba(34,197,94,0.5);
      color: #bbf7d0;
    }
    .mode-badge.router-local {
      background: rgba(59,130,246,0.12);
      border-color: rgba(59,130,246,0.5);
      color: #bfdbfe;
    }
    .mode-badge.ap-mesh {
      background: rgba(244,114,182,0.12);
      border-color: rgba(244,114,182,0.5);
      color: #f9a8d4;
    }

    .status-row {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 16px;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }
    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      display: inline-block;
    }
    .pill-ok   { background: #16a34a22; color: #4ade80; }
    .pill-bad  { background: #b91c1c22; color: #f87171; }
    .pill-warn { background: #a1620722; color: #facc15; }

    .http-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      align-items: center;
      font-size: 0.8rem;
      margin-bottom: 20px;
      opacity: 0.85;
    }
    .http-row label {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .http-input {
      background: #020617;
      border-radius: 999px;
      border: 1px solid #1e293b;
      padding: 4px 10px;
      color: #e5e7eb;
      font-size: 0.8rem;
      width: 130px;
      outline: none;
    }
    .http-input::placeholder {
      color: #6b7280;
    }
    .http-btn {
      border: none;
      border-radius: 999px;
      padding: 6px 16px;
      font-size: 0.8rem;
      cursor: pointer;
      background: #111827;
      color: #e5e7eb;
      box-shadow: 0 6px 20px rgba(15,23,42,0.8);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.2s ease;
      white-space: nowrap;
    }
    .http-btn:hover {
      background: #020617;
    }
    .http-btn:active {
      transform: scale(0.97);
      box-shadow: 0 3px 12px rgba(0,0,0,0.8);
    }

    /* ===== Desktop grid: ESP1 & ESP2 x (Light1, Light2) ===== */
    .grid {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .grid-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 16px;
    }
    .row-label {
      font-size: 0.78rem;
      opacity: 0.65;
      margin: 2px 4px 4px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .card {
      background: #020617;
      border-radius: 18px;
      padding: 16px 20px 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.7);
      text-align: center;
      border: 1px solid #1e293b;
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(148,163,184,0.06), transparent 55%);
      pointer-events: none;
    }
    .card h2 {
      margin: 0 0 4px;
      font-size: 1.0rem;
    }
    .device-topic {
      font-size: 0.7rem;
      opacity: 0.6;
      margin-bottom: 6px;
    }

    .circle-wrapper {
      display: flex;
      justify-content: center;
      margin: 8px 0 6px;
    }
    .circle-button {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: 2px solid #1f2937;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(15,23,42,1);
      background: radial-gradient(circle at 30% 20%, #111827, #020617);
      transition: background 0.18s ease, box-shadow 0.18s ease, transform 0.12s ease, border-color 0.12s ease;
    }
    .circle-button .icon {
      font-size: 1.6rem;
    }
    .circle-button.on {
      background: radial-gradient(circle at 30% 20%, #facc15, #f97316);
      box-shadow: 0 0 45px rgba(250,204,21,0.9);
      border-color: rgba(250,204,21,0.9);
      transform: translateY(-1px);
      color: #111827;
    }
    .circle-button.off {
      color: #e5e7eb;
    }

    .state-text {
      font-size: 0.88rem;
      margin-bottom: 2px;
    }
    .small {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .hint {
      text-align: center;
      font-size: 0.75rem;
      opacity: 0.6;
      margin-top: 16px;
    }
    .hint code {
      background: #020617;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #1e293b;
    }

    /* ===== Mobile Quick Control ===== */
    .mobile-panel {
      display: none;
      margin-bottom: 18px;
    }
    .mobile-panel-title {
      font-size: 0.95rem;
      text-align: center;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    .mobile-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .mobile-card {
      background: #020617;
      border-radius: 18px;
      padding: 10px 10px 12px;
      border: 1px solid #1e293b;
      box-shadow: 0 7px 24px rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    .mobile-label {
      font-size: 0.78rem;
      opacity: 0.75;
    }
    .mobile-round {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #111827;
      background: radial-gradient(circle at 30% 20%, #111827, #020617);
      cursor: pointer;
      transition: background 0.16s ease, box-shadow 0.16s ease, transform 0.08s ease, border-color 0.16s ease;
    }
    .mobile-round .icon {
      font-size: 1.4rem;
    }
    .mobile-round.on {
      background: radial-gradient(circle at 30% 20%, #facc15, #f97316);
      color: #111827;
      border-color: rgba(250,204,21,0.9);
      box-shadow: 0 0 35px rgba(250,204,21,0.7);
      transform: translateY(-1px);
    }
    .mobile-state {
      font-size: 0.8rem;
      font-weight: 600;
    }

    @media (max-width: 768px) {
      .grid-row {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 640px) {
      .mobile-panel {
        display: block;
      }
      .grid {
        display: none;
      }
      .container {
        padding-top: 18px;
      }
      h1 {
        font-size: 1.25rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Smart Home Mesh â€“ ESP1 &amp; ESP2</h1>
    <div id="modeLabel" class="mode">Connectingâ€¦</div>

    <!-- Mode badge -->
    <div class="mode-badge-wrapper">
      <span id="scenarioBadge" class="mode-badge router-cloud">
        Mode: Detectingâ€¦
      </span>
    </div>

    <div class="status-row">
      <span id="localStatus" class="pill pill-warn">Local: connectingâ€¦</span>
      <span id="cloudStatus" class="pill pill-warn">Cloud: connectingâ€¦</span>
    </div>

    <!-- HTTP fallback controls -->
    <div class="http-row">
      <label>
        ESP1 IP:
        <input
          id="esp1Ip"
          class="http-input"
          placeholder="192.168.4.1"
          value="192.168.4.1"
        />
      </label>
      <label>
        ESP2 IP:
        <input
          id="esp2Ip"
          class="http-input"
          placeholder="192.168.4.2"
          value=""
        />
      </label>
      <button id="httpFallbackBtn" class="http-btn">
        HTTP Fallback: Poll /api/state
      </button>
    </div>

    <!-- ===== Mobile quick control ===== -->
    <div class="mobile-panel">
      <div class="mobile-panel-title">Quick Control (Mobile)</div>
      <div class="mobile-grid">
        <div class="mobile-card">
          <div class="mobile-label">ESP1 Light 1</div>
          <div class="mobile-round" id="mround-esp1_light">
            <span class="icon">ðŸ’¡</span>
          </div>
          <div class="mobile-state" id="mstate-esp1_light">OFF</div>
        </div>
        <div class="mobile-card">
          <div class="mobile-label">ESP1 Light 2</div>
          <div class="mobile-round" id="mround-esp1_light2">
            <span class="icon">ðŸ’¡</span>
          </div>
          <div class="mobile-state" id="mstate-esp1_light2">OFF</div>
        </div>
        <div class="mobile-card">
          <div class="mobile-label">ESP2 Light 1</div>
          <div class="mobile-round" id="mround-esp2_light">
            <span class="icon">ðŸ’¡</span>
          </div>
          <div class="mobile-state" id="mstate-esp2_light">OFF</div>
        </div>
        <div class="mobile-card">
          <div class="mobile-label">ESP2 Light 2</div>
          <div class="mobile-round" id="mround-esp2_light2">
            <span class="icon">ðŸ’¡</span>
          </div>
          <div class="mobile-state" id="mstate-esp2_light2">OFF</div>
        </div>
      </div>
    </div>

    <!-- ===== Desktop / tablet grid ===== -->
    <div class="grid">
      <div class="row-label">ESP1</div>
      <div class="grid-row">
        <div class="card" id="card-esp1_light">
          <h2>ESP1 â€“ Light 1</h2>
          <div class="device-topic">
            CMD: home/esp1/light/cmd &nbsp;Â·&nbsp;
            STATE: home/esp1/light/state
          </div>
          <div class="circle-wrapper">
            <div class="circle-button off" id="circle-esp1_light">
              <span class="icon">ðŸ’¡</span>
            </div>
          </div>
          <div class="state-text" id="stateText-esp1_light">Light 1 is OFF</div>
          <div class="small" id="sourceText-esp1_light">Waiting for stateâ€¦</div>
        </div>

        <div class="card" id="card-esp1_light2">
          <h2>ESP1 â€“ Light 2</h2>
          <div class="device-topic">
            CMD: home/esp1/light2/cmd &nbsp;Â·&nbsp;
            STATE: home/esp1/light2/state
          </div>
          <div class="circle-wrapper">
            <div class="circle-button off" id="circle-esp1_light2">
              <span class="icon">ðŸ’¡</span>
            </div>
          </div>
          <div class="state-text" id="stateText-esp1_light2">Light 2 is OFF</div>
          <div class="small" id="sourceText-esp1_light2">Waiting for stateâ€¦</div>
        </div>
      </div>

      <div class="row-label" style="margin-top:10px;">ESP2</div>
      <div class="grid-row">
        <div class="card" id="card-esp2_light">
          <h2>ESP2 â€“ Light 1</h2>
          <div class="device-topic">
            CMD: home/esp2/light/cmd &nbsp;Â·&nbsp;
            STATE: home/esp2/light/state
          </div>
          <div class="circle-wrapper">
            <div class="circle-button off" id="circle-esp2_light">
              <span class="icon">ðŸ’¡</span>
            </div>
          </div>
          <div class="state-text" id="stateText-esp2_light">Light 1 is OFF</div>
          <div class="small" id="sourceText-esp2_light">Waiting for stateâ€¦</div>
        </div>

        <div class="card" id="card-esp2_light2">
          <h2>ESP2 â€“ Light 2</h2>
          <div class="device-topic">
            CMD: home/esp2/light2/cmd &nbsp;Â·&nbsp;
            STATE: home/esp2/light2/state
          </div>
          <div class="circle-wrapper">
            <div class="circle-button off" id="circle-esp2_light2">
              <span class="icon">ðŸ’¡</span>
            </div>
          </div>
          <div class="state-text" id="stateText-esp2_light2">Light 2 is OFF</div>
          <div class="small" id="sourceText-esp2_light2">Waiting for stateâ€¦</div>
        </div>
      </div>
    </div>

    <div class="hint">
      MQTT topics:<br />
      <code>home/esp1/{light|light2}/{cmd|state}</code>,
      <code>home/esp2/{light|light2}/{cmd|state}</code>.<br/>
      HTTP fallback uses:<br />
      <code>/api/set?node=1|2&amp;light=0|1&amp;light2=0|1</code><br />
      States via:<br />
      <code>/api/state</code> on each ESP.
    </div>
  </div>

  <script>
    // ====== CONFIG (topics & MQTT) ======
    const DEVICES = {
      esp1_light: {
        id: "esp1_light",
        label: "ESP1 â€“ Light 1",
        type: "light",
        cmdTopic: "home/esp1/light/cmd",
        stateTopic: "home/esp1/light/state",
        state: "OFF"
      },
      esp1_light2: {
        id: "esp1_light2",
        label: "ESP1 â€“ Light 2",
        type: "light",
        cmdTopic: "home/esp1/light2/cmd",
        stateTopic: "home/esp1/light2/state",
        state: "OFF"
      },
      esp2_light: {
        id: "esp2_light",
        label: "ESP2 â€“ Light 1",
        type: "light",
        cmdTopic: "home/esp2/light/cmd",
        stateTopic: "home/esp2/light/state",
        state: "OFF"
      },
      esp2_light2: {
        id: "esp2_light2",
        label: "ESP2 â€“ Light 2",
        type: "light",
        cmdTopic: "home/esp2/light2/cmd",
        stateTopic: "home/esp2/light2/state",
        state: "OFF"
      }
    };

    const LOCAL_URL = "ws://192.168.0.144:9001"; // optional local broker
    const CLOUD_URL = "wss://855677dcf06a47379e9bb069a058ee3a.s1.eu.hivemq.cloud:8884/mqtt";
    const CLOUD_USER = "SmartLife";
    const CLOUD_PASS = "Metrouni2025";

    const STATE_TOPICS = Object.values(DEVICES).map(d => d.stateTopic);

    const isHttps = window.location.protocol === "https:";
    const canUseLocal = !isHttps; // avoid ws:// from https page

    // ====== UI ELEMENTS ======
    const modeLabel       = document.getElementById("modeLabel");
    const localStatus     = document.getElementById("localStatus");
    const cloudStatus     = document.getElementById("cloudStatus");
    const esp1IpInput     = document.getElementById("esp1Ip");
    const esp2IpInput     = document.getElementById("esp2Ip");
    const httpFallbackBtn = document.getElementById("httpFallbackBtn");
    const scenarioBadge   = document.getElementById("scenarioBadge");

    function setPill(el, text, cls) {
      el.textContent = text;
      el.className = "pill " + cls;
    }

    function updateDeviceUI(deviceId, state, source = "") {
      const dev = DEVICES[deviceId];
      if (!dev) return;

      dev.state = (state || "").toString().toUpperCase() === "ON" ? "ON" : "OFF";

      const circleBtn = document.getElementById("circle-" + deviceId);
      const stateEl   = document.getElementById("stateText-" + deviceId);
      const sourceEl  = document.getElementById("sourceText-" + deviceId);

      const isOn = dev.state === "ON";

      if (circleBtn) {
        circleBtn.classList.toggle("on", isOn);
        circleBtn.classList.toggle("off", !isOn);
      }

      if (stateEl) {
        let label = "Light";
        if (deviceId.endsWith("light2")) label = "Light 2";
        else label = "Light 1";
        stateEl.textContent = isOn ? `${label} is ON` : `${label} is OFF`;
      }

      if (source && sourceEl) {
        sourceEl.textContent = "Last update from: " + source;
      }

      // Mobile
      const mRound = document.getElementById("mround-" + deviceId);
      const mState = document.getElementById("mstate-" + deviceId);
      if (mRound) {
        mRound.classList.toggle("on", isOn);
      }
      if (mState) {
        mState.textContent = isOn ? "ON" : "OFF";
      }
    }

    Object.keys(DEVICES).forEach(id => updateDeviceUI(id, "OFF", ""));

    let client = null;
    let currentMode = ""; // "local" or "cloud"
    let subscriptionsDone = false;
    let apiInfo = null;

    function setupSubscriptions() {
      if (!client || subscriptionsDone) return;
      subscriptionsDone = true;

      client.subscribe(STATE_TOPICS, (err, granted) => {
        if (err) {
          console.error("Subscribe error:", err);
        } else {
          console.log("Subscribed to:", granted.map(g => g.topic).join(", "));
        }
      });

      client.on("message", (topic, payload) => {
        const msg = payload.toString().trim();
        console.log("MQTT:", topic, msg);

        const devEntry = Object.values(DEVICES).find(d => d.stateTopic === topic);
        if (devEntry) {
          const source = currentMode === "local" ? "Local MQTT" :
                         currentMode === "cloud" ? "HiveMQ Cloud" : "Unknown";
          updateDeviceUI(devEntry.id, msg, source);
        }
      });
    }

    function retryConnection() {
      setTimeout(() => {
        modeLabel.textContent = "Retrying connectionâ€¦";
        startConnectionFlow();
      }, 10000);
    }

    function startConnectionFlow() {
      if (canUseLocal) {
        connectLocalFirst();
      } else {
        setPill(localStatus, "Local: disabled over HTTPS", "pill-bad");
        modeLabel.textContent = "HTTPS detected â€“ using Cloud mode";
        connectCloudFallback();
      }
    }

    function connectLocalFirst() {
      modeLabel.textContent = "Trying local brokerâ€¦";
      setPill(localStatus, "Local: connectingâ€¦", "pill-warn");

      const localClient = mqtt.connect(LOCAL_URL, {
        reconnectPeriod: 0,
        connectTimeout: 3000
      });

      let resolved = false;

      localClient.on("connect", () => {
        console.log("Connected to local broker");
        resolved = true;
        currentMode = "local";
        client = localClient;

        modeLabel.textContent = "Connected (Local MQTT)";
        setPill(localStatus, "Local: connected", "pill-ok");
        setPill(cloudStatus, "Cloud: standby", "pill-warn");

        setupSubscriptions();
      });

      localClient.on("error", (err) => {
        console.error("Local MQTT error:", err && err.message);
        localClient.end(true);
        if (!resolved) {
          resolved = true;
          setPill(localStatus, "Local: failed", "pill-bad");
          connectCloudFallback();
        }
      });

      localClient.on("close", () => {
        console.log("Local MQTT closed");
        if (!resolved) {
          resolved = true;
          setPill(localStatus, "Local: closed", "pill-bad");
          connectCloudFallback();
        } else if (currentMode === "local") {
          setPill(localStatus, "Local: disconnected", "pill-bad");
          modeLabel.textContent = "Local lost, trying Cloudâ€¦";
          connectCloudFallback();
        }
      });
    }

    function connectCloudFallback() {
      modeLabel.textContent = "Trying HiveMQ Cloudâ€¦";
      setPill(cloudStatus, "Cloud: connectingâ€¦", "pill-warn");

      const cloudClient = mqtt.connect(CLOUD_URL, {
        username: CLOUD_USER,
        password: CLOUD_PASS,
        reconnectPeriod: 0,
        connectTimeout: 4000
      });

      let resolved = false;

      cloudClient.on("connect", () => {
        console.log("Connected to HiveMQ Cloud");
        resolved = true;
        currentMode = "cloud";
        client = cloudClient;

        modeLabel.textContent = "Connected (Cloud MQTT)";
        setPill(cloudStatus, "Cloud: connected", "pill-ok");
        if (localStatus.textContent.includes("connecting")) {
          setPill(localStatus, "Local: unavailable", "pill-bad");
        }

        setupSubscriptions();
      });

      cloudClient.on("error", (err) => {
        console.error("Cloud MQTT error:", err && err.message);
        cloudClient.end(true);
        if (!resolved) {
          resolved = true;
          setPill(cloudStatus, "Cloud: failed", "pill-bad");
          modeLabel.textContent = "No MQTT broker available â€“ HTTP only";
          retryConnection();
        }
      });

      cloudClient.on("close", () => {
        console.log("Cloud MQTT closed");
        if (!resolved) {
          resolved = true;
          setPill(cloudStatus, "Cloud: closed", "pill-bad");
          modeLabel.textContent = "No MQTT broker available â€“ HTTP only";
          retryConnection();
        } else if (currentMode === "cloud") {
          setPill(cloudStatus, "Cloud: disconnected", "pill-bad");
          modeLabel.textContent = "Disconnected from Cloud â€“ HTTP only";
          retryConnection();
        }
      });
    }

    // ====== HTTP STATE (/api/state) ======
    function applyHttpState(json, sourceLabel) {
      if (!json || typeof json !== "object") return;

      const src = `HTTP ${sourceLabel}`;
      const node          = Number(json.node);
      const light         = Number(json.light)  === 1 ? "ON" : "OFF";
      const light2        = Number(json.light2) === 1 ? "ON" : "OFF";
      const remoteNode    = Number(json.remote_node);
      const remoteLight   = Number(json.remote_light)  === 1 ? "ON" : "OFF";
      const remoteLight2  = Number(json.remote_light2) === 1 ? "ON" : "OFF";

      if (node === 1) {
        updateDeviceUI("esp1_light",  light,  src);
        updateDeviceUI("esp1_light2", light2, src);
        if (remoteNode === 2) {
          updateDeviceUI("esp2_light",  remoteLight,  src);
          updateDeviceUI("esp2_light2", remoteLight2, src);
        }
      } else if (node === 2) {
        updateDeviceUI("esp2_light",  light,  src);
        updateDeviceUI("esp2_light2", light2, src);
        if (remoteNode === 1) {
          updateDeviceUI("esp1_light",  remoteLight,  src);
          updateDeviceUI("esp1_light2", remoteLight2, src);
        }
      }
    }

    async function pollNode(ip, label) {
      if (!ip) return;
      const url = `http://${ip}/api/state`;
      console.log("HTTP polling:", url);

      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) {
          console.warn("HTTP non-OK:", res.status, res.statusText);
          return;
        }
        const json = await res.json();
        console.log("HTTP state from", label, json);
        applyHttpState(json, label);
      } catch (err) {
        console.error("HTTP error for", ip, err);
      }
    }

    async function httpFallbackPoll() {
      const ip1 = esp1IpInput.value.trim();
      const ip2 = esp2IpInput.value.trim();

      if (!ip1 && !ip2) {
        alert("No ESP IPs known. (initApi should fill these automatically.)");
        return;
      }

      modeLabel.textContent = "HTTP fallback: polling /api/stateâ€¦";
      await Promise.all([
        pollNode(ip1, "ESP1"),
        pollNode(ip2, "ESP2")
      ]);
      modeLabel.textContent = "HTTP fallback: last poll completed";
    }

    httpFallbackBtn.addEventListener("click", httpFallbackPoll);

    // ====== HTTP commands for lights ======
    async function sendLightCommand(deviceId, newState) {
      const [nodeStr, devType] = deviceId.split("_"); // "esp1", "light" or "light2"
      const nodeNum = nodeStr === "esp1" ? 1 : 2;

      let ip = "";
      if (nodeNum === 1) {
        ip = esp1IpInput.value.trim() || window.location.hostname;
      } else if (nodeNum === 2) {
        ip = esp2IpInput.value.trim() || window.location.hostname;
      }

      if (!ip) {
        alert("No IP known for " + nodeStr.toUpperCase());
        return;
      }

      const val = newState === "ON" ? 1 : 0;
      const url = `http://${ip}/api/set?node=${nodeNum}&${devType}=${val}`;

      console.log("HTTP SET (light) â†’", url);
      try {
        const res = await fetch(url, { method: "GET", cache: "no-store" });
        if (!res.ok) {
          console.warn("HTTP SET non-OK:", res.status, res.statusText);
        } else {
          const json = await res.json();
          console.log("HTTP SET resp:", json);
          applyHttpState(json, `ESP${nodeNum}`);
        }
      } catch (err) {
        console.error("HTTP SET error:", err);
        alert("HTTP command failed for " + nodeStr.toUpperCase());
      }
    }

    // ====== Button bindings ======
    function bindButtons() {
      Object.values(DEVICES).forEach(dev => {
        const circle = document.getElementById("circle-" + dev.id);
        if (circle) {
          circle.addEventListener("click", async () => {
            const newState = dev.state === "ON" ? "OFF" : "ON";
            if (client && client.connected) {
              client.publish(dev.cmdTopic, newState, { qos: 0, retain: false });
            } else {
              await sendLightCommand(dev.id, newState);
            }
          });
        }

        const mRound = document.getElementById("mround-" + dev.id);
        if (mRound) {
          mRound.addEventListener("click", async () => {
            const newState = dev.state === "ON" ? "OFF" : "ON";
            if (client && client.connected) {
              client.publish(dev.cmdTopic, newState, { qos: 0, retain: false });
            } else {
              await sendLightCommand(dev.id, newState);
            }
          });
        }
      });
    }

    // ====== Scenario Mode Badge Logic ======
    function updateScenarioBadge() {
      if (!scenarioBadge) return;

      let scenarioClass = "router-cloud";
      let label = "Mode: Router+Cloud";

      if (client && client.connected) {
        if (currentMode === "cloud") {
          scenarioClass = "router-cloud";
          label = "Mode: Router+Cloud (MQTT)";
        } else if (currentMode === "local") {
          scenarioClass = "router-local";
          label = "Mode: Router Local (MQTT)";
        }
      } else {
        const host = window.location.hostname || "";
        if (/^192\.168\.4\./.test(host)) {
          scenarioClass = "ap-mesh";
          label = "Mode: AP Mesh (HTTP only)";
        } else if (/^192\.168\.|^10\.|^172\.(1[6-9]|2\d|3[0-1])\./.test(host)) {
          scenarioClass = "router-local";
          label = "Mode: Router Local (HTTP only)";
        } else {
          scenarioClass = "router-cloud";
          label = "Mode: Router+Cloud (offline / HTTP)";
        }

        if (apiInfo && typeof apiInfo.mode === "string") {
          if (apiInfo.mode === "AP_STA" || apiInfo.mode === "AP") {
            scenarioClass = "ap-mesh";
            label = "Mode: AP Mesh (HTTP only)";
          } else if (apiInfo.mode === "STA") {
            scenarioClass = "router-local";
            label = "Mode: Router Local (HTTP only)";
          }
        }
      }

      scenarioBadge.textContent = label;
      scenarioBadge.className = "mode-badge " + scenarioClass;
    }

    // ====== initApi ======
    async function initApi() {
      const host = window.location.hostname || "";

      if (/^192\.168\.4\./.test(host)) {
        esp1IpInput.value = host;
        esp2IpInput.value = host;
      } else if (/^192\.168\.|^10\.|^172\.(1[6-9]|2\d|3[0-1])\./.test(host)) {
        esp1IpInput.value = host;
        esp2IpInput.value = host;
      }

      if (host && host !== "localhost") {
        try {
          const res = await fetch(`http://${host}/api/info`, { cache: "no-store" });
          if (res.ok) {
            apiInfo = await res.json();
            console.log("API info:", apiInfo);
          } else {
            console.log("/api/info not available, status:", res.status);
          }
        } catch (e) {
          console.log("Could not fetch /api/info:", e.message || e);
        }
      }

      updateScenarioBadge();
    }

    // ====== Startup ======
    bindButtons();
    initApi();
    startConnectionFlow();
    updateScenarioBadge();
    setInterval(updateScenarioBadge, 2000);
  </script>
</body>
</html>
